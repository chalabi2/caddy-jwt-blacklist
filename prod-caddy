{
	# Global options
	email chalabi@chandrastation.com
	# acme_ca https://acme-staging-v02.api.letsencrypt.org/directory

	# Admin interface - bind to localhost for monitoring access only
	admin localhost:2019

	# Enable Prometheus support
	metrics

	# Global JSON access log
	log {
		output stdout
		format json
		level INFO
	}
}

import snippets/rate_limits.caddy

# PUBLIC (no auth)
nodes.chandrastation.com {
	tls {
		dns cloudflare {env.CLOUDFLARE_API_TOKEN}
	}

	route {
		# Enable usage metrics tracking for all public requests
		usage

		# import rate_limit_public

		# Handle CORS preflight requests
		@options method OPTIONS
		handle @options {
			header {
				Access-Control-Allow-Origin *
				Access-Control-Allow-Methods "GET, POST, OPTIONS"
				Access-Control-Allow-Headers "Origin, X-Requested-With, Content-Type, Accept, Authorization"
				Access-Control-Max-Age 86400
			}
			respond "" 204
		}

		handle /status {
			respond `{"status":"ok","service":"chandra-station-public","timestamp":"{time.now.unix}","available_chains":[...]}`
		}

		import chains/public/*.caddy

		handle {
			respond `{"error":"not_found","message":"Endpoint not found"}` 404
		}
	}

	handle_errors {
		respond `{"error":"{http.error.status_code}","message":"{http.error.status_text}"}` {http.error.status_code}
	}
}

# PRIVATE (Unified JWT auth + blacklist)
api.chandrastation.com {
	tls {
		dns cloudflare {env.CLOUDFLARE_API_TOKEN}
	}

	route {
		# Unified JWT Authentication + Blacklist Check
		# This single directive handles both JWT validation and Redis blacklist checking
		jwt_blacklist {
			# Redis configuration for blacklist checking
			redis_addr {env.REDIS_URL}
			redis_password {env.REDIS_PASSWORD}
			redis_db 0
			blacklist_prefix "BLACKLIST:key:"
			fail_open true
			timeout 50ms
			log_blocked true
			
			# TLS configuration for Upstash Redis
			tls {
				enabled true
				min_version "1.2"
			}

			# JWT authentication configuration (integrated)
			sign_key {env.JWT_SECRET}
			sign_alg HS256
			
			# Token extraction sources (in order of precedence)
			from_query api_key access_token token
			from_header Authorization X-Api-Token X-API-Key
			from_cookies session_token
			
			# Claims configuration
			user_claims sub jti uid user_id
			meta_claims "tier" "scope"
		}

		# Handle CORS preflight requests FIRST (before any auth)
		@options method OPTIONS
		handle @options {
			header {
				Access-Control-Allow-Origin *
				Access-Control-Allow-Methods "GET, POST, OPTIONS"
				Access-Control-Allow-Headers "Origin, X-Requested-With, Content-Type, Accept, Authorization, X-API-Key"
				Access-Control-Max-Age 86400
			}
			respond "" 204
		}

		# Enable usage metrics tracking for all private requests
		usage

		# Apply rate limiting (import should be defined elsewhere)
		import rate_limit_authenticated

		# Add user headers for downstream services
		header {
			X-User-ID {http.auth.user.id}
			X-User-Tier {http.auth.user.tier}
			X-User-Scope {http.auth.user.scope}
			X-API-Key-ID {http.auth.user.jti}
			X-Rate-Limit-Applied {http.auth.user.tier}
		}

		# Handle specific endpoints
		handle /status {
			respond `{"status":"ok","service":"chandra-station-private","timestamp":"{time.now.unix}","user_id":"{http.auth.user.id}","tier":"{http.auth.user.tier}","scope":"{http.auth.user.scope}","api_key_id":"{http.auth.user.jti}"}`
		}

		import chains/private/*.caddy

		handle {
			respond `{"error":"not_found","message":"Endpoint not found"}` 404
		}
	}

	handle_errors {
		@blacklist_error expression `{http.error.status_code} == 401 && "blacklisted" in {http.error.message}`
		header @blacklist_error {
			X-Error-Type "api_key_blacklisted"
			WWW-Authenticate "Bearer"
		}
		respond @blacklist_error `{"error":"api_key_blacklisted","message":"API key has been disabled due to subscription changes","code":401,"details":"Please check your subscription status or generate a new API key"}` 401

		@auth_error expression `{http.error.status_code} == 401`
		header @auth_error {
			X-Error-Type "authentication_failed"
			WWW-Authenticate "Bearer"
		}
		respond @auth_error `{"error":"unauthorized","message":"Invalid or missing API key","code":401}` 401

		@rate_limit_error expression `{http.error.status_code} == 429`
		header @rate_limit_error {
			X-RateLimit-Limit-Tier {http.auth.user.tier}
			X-RateLimit-Reset {time.now.unix}
			Retry-After 60
		}
		respond @rate_limit_error `{"error":"rate_limit_exceeded","message":"Rate limit exceeded"}` 429

		respond `{"error":"{http.error.status_code}","message":"{http.error.status_text}"}` {http.error.status_code}
	}

	# Apply CORS headers to all other requests
	header {
		Access-Control-Allow-Origin *
		Access-Control-Allow-Methods "GET, POST, OPTIONS"
		Access-Control-Allow-Headers "Origin, X-Requested-With, Content-Type, Accept, Authorization, X-API-Key"
		Access-Control-Expose-Headers "X-User-ID, X-User-Tier, X-API-Key-ID, X-RateLimit-Reset"
	}
}

import chains/public/grpc/*
import chains/private/grpc/*
import sites-enabled/*