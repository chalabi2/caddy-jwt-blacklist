# Caddy JWT Blacklist Plugin - Unified JWT Authentication and Blacklist
# This configuration demonstrates the integrated JWT authentication and blacklist functionality

{
	admin localhost:2019
	
	log {
		output stdout
		format json
		level INFO
	}
}

# Example 1: Basic JWT authentication with blacklist checking
localhost:8080 {
	jwt_blacklist {
		# Redis configuration
		redis_addr {env.REDIS_URL}
		redis_password {env.REDIS_PASSWORD}
		redis_db 0
		blacklist_prefix "BLACKLIST:key:"
		timeout 50ms
		fail_open true
		log_blocked true
		
		# TLS configuration for cloud Redis (optional)
		tls {
			enabled true
			min_version "1.2"
		}
		
		# JWT authentication configuration
		sign_key {env.JWT_SECRET}
		sign_alg HS256
		
		# Token extraction sources (in order of precedence)
		from_query api_key access_token token
		from_header Authorization X-Api-Token X-API-Key
		from_cookies session_token
		
		# JWT claims configuration
		user_claims sub
		meta_claims "tier" "scope"
		
		# Optional: JWK support for asymmetric keys
		# jwk_url https://your-auth-server.com/.well-known/jwks.json
		
		# Optional: Skip JWT signature verification (not recommended for production)
		# skip_verification
		
		# Optional: Validate issuer and audience
		# issuer_whitelist https://your-auth-server.com
		# audience_whitelist https://api.example.com
	}
	
	# Your application routes
	handle /health {
		respond `{"status":"ok","service":"jwt-blacklist","user_id":"{http.auth.user.id}","tier":"{http.auth.user.tier}","timestamp":"{time.now.unix}"}`
	}
	
	handle /api/* {
		respond `{"message":"API access granted","user_id":"{http.auth.user.id}","tier":"{http.auth.user.tier}","path":"{uri}","timestamp":"{time.now.unix}"}`
	}
	
	handle {
		respond `{"message":"JWT Authentication + Blacklist Server","endpoints":["/health","/api/*"],"note":"Include Bearer token, api_key parameter, or session cookie to authenticate"}`
	}
	
	# Error handling
	handle_errors {
		@blacklist_error expression `{http.error.status_code} == 401 && "blacklisted" in {http.error.message}`
		respond @blacklist_error `{"error":"api_key_blacklisted","message":"API key has been disabled due to subscription changes","code":401,"details":"Please check your subscription status or generate a new API key"}` 401
		
		@auth_error expression `{http.error.status_code} == 401`
		respond @auth_error `{"error":"unauthorized","message":"Invalid or missing API key","code":401,"details":"Please provide a valid JWT token"}` 401
		
		respond `{"error":"{http.error.status_code}","message":"{http.error.status_text}"}` {http.error.status_code}
	}
}

# Example 2: Production API server with advanced JWT configuration
api.example.com {
	jwt_blacklist {
		redis_addr {env.REDIS_URL}
		redis_password {env.REDIS_PASSWORD}
		redis_db 0
		blacklist_prefix "BLACKLIST:key:"
		timeout 100ms
		fail_open false  # Fail closed in production
		log_blocked true
		
		# Production JWT configuration
		sign_key {env.JWT_SECRET}
		sign_alg HS256
		
		# Multiple token sources
		from_query api_key access_token
		from_header Authorization X-API-Key
		from_cookies auth_session
		
		# Extract user information
		user_claims sub uid user_id
		meta_claims "tier->user_tier" "scope->access_scope" "org_id->organization"
		
		# Validation
		issuer_whitelist https://auth.example.com
		audience_whitelist https://api.example.com
	}
	
	# API routes with user context available
	route /v1/* {
		respond `{"api_version":"v1","user_id":"{http.auth.user.id}","tier":"{http.auth.user.user_tier}","scope":"{http.auth.user.access_scope}","path":"{uri}"}`
	}
	
	route /admin/* {
		# Admin endpoints could have additional authorization logic here
		respond `{"admin_access":"granted","user_id":"{http.auth.user.id}","organization":"{http.auth.user.organization}"}`
	}
	
	respond `{"error":"not_found","message":"API endpoint not found"}` 404
}